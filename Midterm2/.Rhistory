library(ISLR)
library(ISLR)
head(Auto)
library(ggplot2)
library(plotly)
ggplot(auto, aes(horsepower, mpg)) +
geom_point()
ggplot(Auto, aes(horsepower, mpg)) +
geom_point()
ggplot(Auto, aes(horsepower, mpg)) +
geom_point() +
labels(title="title")
ggplot(Auto, aes(horsepower, mpg)) +
geom_point() +
labs(title="title")
p1 <- ggplot(Auto, aes(horsepower, mpg)) +
geom_point() +
labs(title="title")
ggplotly(p1)
lm1 <- lm(mpg ~ poly(horsepower, 2), data = Auto)
summary(lm1)A
lm1 <- lm(mpg ~ poly(horsepower, 2), data = Auto)
summary(lm1)
lm1 <- lm(mpg ~ poly(horsepower, 2), data = Auto)
summary(lm1)
lm2 <- lm(mpg ~ horsepower + I(horsepower^2), data = Auto)
summary(lm2)
lm1 <- lm(mpg ~ poly(horsepower, 2), data = Auto)
summary(lm1)
predict(lm1, newdata = data.frame(horsepower=150), interval = "prediction")
p2 <- ggplot(Auto, aes(horsepower, mpg)) +
geom_point() +
stat_smooth(method="lm", formula = y ~ poly(x, 2)) +
labs(title="title")
ggplotly(p2)
p3 <- ggplot(lm1, aes(fitted(lm1), resid(lm1))) +
geom_point() +
geom_hline(yintercept=0)
resid(lm1)
p3 <- ggplot(lm1, aes(fitted(lm1), resid(lm1))) +
geom_point() +
geom_hline(yintercept=0)
head(resid(lm1))
p3 <- ggplot(lm1, aes(fitted(lm1), resid(lm1))) +
geom_point() +
geom_hline(yintercept=0)
ggplot(resid(lm1), aes()) +
geom_qq() +
geom_qq_line(col="red") +
ggtitle("QQ Plot of Model Residuals")
p3 <- ggplot(lm1, aes(fitted(lm1), resid(lm1))) +
geom_point() +
geom_hline(yintercept=0)
ggplot(Residuals = resid(lm1), aes(sample = Residuals)) +
geom_qq() +
geom_qq_line(col="red") +
ggtitle("QQ Plot of Model Residuals")
p3 <- ggplot(lm1, aes(fitted(lm1), resid(lm1))) +
geom_point() +
geom_hline(yintercept=0)
ggplot(data.frame(Residuals = resid(lm1)), aes(sample = Residuals)) +
geom_qq() +
geom_qq_line(col="red") +
ggtitle("QQ Plot of Model Residuals")
p3 <- ggplot(lm1, aes(fitted(lm1), resid(lm1))) +
geom_point() +
geom_hline(yintercept=0)
p4 <- ggplot(data.frame(Residuals = resid(lm1)), aes(sample = Residuals)) +
geom_qq() +
geom_qq_line(col="red") +
ggtitle("QQ Plot of Model Residuals")
ggplotly(p3)
ggplotly(p4)
head(Carseats)
lm2 <- lm(Sales ~ Price + factor(Urban) + factor(US), data = Carseats)
summary(lm2)
lm3 <- lm(Sales ~ Price + factor(US), data = Carseats)
summary(lm3)
par(mfrow=c(2,2))
plot(resid(lm2) ~ fitted(lm2))
abline(h=0, col="red")
qqnorm(rstandard(lm2))
qqline(rstandard(lm2))
#versus
plot(resid(lm3) ~ fitted(lm3))
abline(h=0, col="red")
par(mfrow=c(2,2))
plot(resid(lm2) ~ fitted(lm2))
abline(h=0, col="red")
qqnorm(rstandard(lm2))
qqline(rstandard(lm2))
#versus
plot(resid(lm3) ~ fitted(lm3))
abline(h=0, col="red")
qqnorm(rstandard(lm3))
qqline(rstandard(lm3))
confint(lm3)
pacman::p_load(MASS, tidyverse)
data(Boston)
head(Boston)
lmB <- lm(medv ~ dis + rm + tax + chas, data=Boston)
summary(lmB)
X <- Boston %>% mutate(intercept = rep(1, nrow(Boston))) %>%
select(intercept, dis, rm, tax, chas) %>% as.matrix()
beta.hat <- solve(t(X)%*%X)%*%t(X)%*%as.matrix(Boston$medv)
X <- Boston %>% mutate(intercept = rep(1, nrow(Boston))) %>%
select(intercept, dis, rm, tax, chas) %>% as.matrix()
beta.hat <- solve(t(X)%*%X)%*%t(X)%*%as.matrix(Boston$medv)
beta.hat
#Create a matrix of predictors using the dis, rm, tax, and chas columns of the Boston dataset, including a column of 1s to account for beta_0
X <- as.matrix(cbind(1, Boston[, c('dis', 'rm', 'tax', 'chas')]))
#Create a matrix of responses
Y <- as.matrix(Boston['medv'])
#Get the transpose of the predictors matrix
X_t <- t(X)
#Apply the least-squares estimates formula
Beta <- solve(X_t %*% X) %*% X_t %*% Y
Beta
#First we obtain the factors necessary to calculate the variance of predicted values
RSS <- sum((residuals(lm1))^2)
n <- nrow(Boston)
#Calculate sigma squared manually
sigma_squared <- RSS / (n - 4 - 1)
#Now we apply the given formula to obtain the covariance matrix
Cov <- sigma_squared * solve(X_t %*% X)
#From the matrix we isolate the diagonal entries and square root them to obtain the standard errors
Err <- sqrt(diag(Cov))
Err
#First we obtain the factors necessary to calculate the variance of predicted values
RSS <- sum((residuals(lmB))^2)
n <- nrow(Boston)
#Calculate sigma squared manually
sigma_squared <- RSS / (n - 4 - 1)
#Now we apply the given formula to obtain the covariance matrix
Cov <- sigma_squared * solve(X_t %*% X)
#From the matrix we isolate the diagonal entries and square root them to obtain the standard errors
Err <- sqrt(diag(Cov))
Err
